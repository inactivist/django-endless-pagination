Generic views
=============

Django 1.3 introduced class based generic views
(see https://docs.djangoproject.com/en/1.3/topics/class-based-views/).

This application provides a customized subclass of 
*django.views.generic.ListView* that allows AJAX pagination of a 
list of objects (usually a queryset).


AjaxListView reference
~~~~~~~~~~~~~~~~~~~~~~

.. py:module:: endless_pagination.views

.. py:class:: AjaxListView(django.views.generic.ListView)

    A subclass of *django.views.generic.ListView* that allows AJAX
    pagination of a list of objects.
    
    You can use this class based view in place of *ListView* in order to
    recreate the behaviour of the *page_template* decorator.
    
    For instance, assume you have this code (taken from Django docs)::
    
        from django.conf.urls.defaults import *
        from django.views.generic import ListView
        from books.models import Publisher

        urlpatterns = patterns('',
            (r'^publishers/$', ListView.as_view(model=Publisher)),
        )
        
    You want to AJAX paginate publishers, so, as seen, you need to switch
    the template if the request is AJAX and put the page template 
    into the context as a variable named *page_template*.
    
    This is straightforward, you only need to replace the view class, e.g.::
    
        from django.conf.urls.defaults import *
        from books.models import Publisher
        
        from endless_pagination.views import AjaxListView

        urlpatterns = patterns('',
            (r'^publishers/$', AjaxListView.as_view(model=Publisher)),
        )
        
    NOTE: Django >= 1.3 is required to use this view.
    
    
    .. py:attribute:: key 
    
        the querystring key used for the current pagination
        (default: *settings.ENDLESS_PAGINATION_PAGE_LABEL*)
    
    .. py:attribute:: page_template
    
        the template used for the paginated objects
        
    .. py:attribute:: page_template_suffix
    
        the template suffix used for autogenerated page_template name
        (when not given, default='_page')
        
    
    .. py:method:: get_context_data(self, **kwargs)
    
        Adds the *page_template* variable in the context.
        
        If the *page_template* is not given as a kwarg of the *as_view*
        method then it is invented using app label, model name
        (obviously if the list is a queryset), *self.template_name_suffix*
        and *self.page_template_suffix*.
        
        For instance, if the list is a queryset of *blog.Entry*, 
        the template will be *blog/entry_list_page.html*.
    
    .. py:method:: get_template_names(self)
    
        Switch the templates for AJAX requests.
        
    .. py:method:: get_page_template(self, **kwargs)
    
        Only called if *page_template* is not given as a kwarg of 
        *self.as_view*.
